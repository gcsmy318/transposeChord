<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Transpose Chord — Lyrics & Chords (Select song from list)</title>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;600;700&family=JetBrains+Mono:wght@300;400;600;700&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#071124;
    --card:#081428;
    --muted:#9aa6b2;
    --accent:#7dd3fc;
    --radius:12px;
    --gap:16px;
    --text:#e6eef6;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:"Sarabun", "Noto Sans Thai", sans-serif;
    background:linear-gradient(180deg,#071124 0%,#05101a 100%);
    color:#e6eef6;
  }
  .topbar{max-width:1200px;margin:18px auto;padding:10px 18px;display:flex;gap:12px;align-items:center}
  h1{margin:0;font-size:18px}
  .container{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1fr 1fr;gap:var(--gap)}
  .card{background:var(--card);border-radius:var(--radius);padding:14px;box-shadow:0 8px 28px rgba(0,0,0,0.45)}
  textarea#editor{
    width:100%;height:420px;padding:14px;border-radius:8px;border:1px solid rgba(255,255,255,0.25);
    background: rgba(255,255,255,0.12); color:#e9f1f8;
    font-family:"JetBrains Mono","Sarabun", monospace; font-size:15px; line-height:1.6; white-space:pre-wrap; resize:vertical;
  }
  .output{
    white-space:pre-wrap; font-family:"JetBrains Mono","Sarabun",monospace; font-size:15px; line-height:1.6; color:#e9f1f8;
    padding:12px;border-radius:8px;min-height:420px;border:1px solid rgba(255,255,255,0.25);background: rgba(255,255,255,0.06);overflow:auto;
  }
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:10px}
  .btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:700;background:var(--accent);color:#022}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.08);color:#cfefff;font-weight:600}
  .small{color:#9fb4c6;font-size:13px}
  .row{display:flex;gap:8px;align-items:center}
  .key-buttons{display:flex;gap:6px;flex-wrap:wrap}
  .key-buttons button{padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  input[type="text"], input[type="search"]{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  #searchResults{margin-top:10px;display:flex;flex-direction:column;gap:8px;max-height:360px;overflow:auto}
  .sr-row{display:flex;gap:10px;padding:8px;border-radius:10px;align-items:flex-start;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.01)}
  .sr-row img{border-radius:6px;object-fit:cover}
  .muted{color:#9fb4c6;font-size:13px}
  .label{font-size:12px;color:#9fb4c6}
  a.preview-link{color:var(--accent); text-decoration:underline}
  .chordpro{color:#7fe3a8}
  /* Modal (list picker) */
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999}
  .modal{background:#fff;color:#000;border-radius:10px;max-width:900px;width:95%;max-height:80vh;overflow:auto;padding:18px}
  .modal h3{margin:0 0 8px 0}
  .song-row{display:flex;justify-content:space-between;align-items:center;padding:8px;border-bottom:1px solid #eee}
  .song-left{flex:1}
  .song-title{font-weight:700}
  .song-meta{color:#666;font-size:13px}
  .song-actions{margin-left:12px}
  .score-badge{background:#0077cc;color:#fff;padding:6px 8px;border-radius:6px;font-weight:700}
  @media(max-width:980px){.container{grid-template-columns:1fr;padding:12px}textarea#editor{height:340px}.output{min-height:340px}}
</style>
</head>
<body>

<div class="topbar">
  <h1>Transpose Chord — เลือกเพลงจากหน้า list</h1>
  <div style="margin-left:auto;display:flex;gap:10px;align-items:center">
    <button id="presentMode" class="btn secondary">Presentation</button>
  </div>
</div>

<div class="container">
  <!-- LEFT -->
  <section class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div class="small">Editor</div>
        <div style="font-weight:700;margin-top:6px">วางเนื้อเพลง + คอร์ด</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="loadSample" class="btn secondary">ตัวอย่าง</button>
        <button id="save" class="btn secondary">บันทึก</button>
        <button id="load" class="btn secondary">เรียกคืน</button>
        <button id="clear" class="btn">ล้าง</button>
      </div>
    </div>

    <textarea id="editor" placeholder="วางเนื้อเพลง + คอร์ด ที่นี่..."></textarea>

    <div class="controls">
      <button id="dec" class="btn">−</button>
      <div id="transposeDisplay" style="min-width:110px;font-weight:700">Transpose: 0</div>
      <button id="inc" class="btn">+</button>

      <input id="range" type="range" min="-12" max="12" value="0" style="width:160px">
      <div id="stepsLabel" class="small">0 semitones</div>

      <div class="row" style="align-items:center">
        <div class="small">ปรับเป็นคีย์:</div>
        <div class="key-buttons" id="keyButtons"></div>
      </div>
    </div>

    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
      <button id="exportTxt" class="btn secondary">Export .txt</button>
      <button id="exportDoc" class="btn secondary">Export .doc</button>
      <button id="exportPdf" class="btn">Export .pdf</button>
      <button id="printPreview" class="btn secondary">ปริ้นผลลัพธ์ (HTML)</button>
      <button id="printAsPdf" class="btn">Print จาก PDF</button>
    </div>

    <!-- Search lyrics (DuckDuckGo + Bing-style site filters) -->
    <div style="margin-top:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <input id="searchQuery" type="search" placeholder="ค้นหาเนื้อเพลง (เช่น ชื่อเพลง)" style="flex:1">
      <button id="doSearch" class="btn secondary">ค้นหา (DuckDuckGo)</button>
    </div>
    <div id="searchResults"></div>
  </section>

  <!-- RIGHT -->
  <section class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div>
        <div class="small">ผลลัพธ์</div>
        <div style="font-weight:700;margin-top:6px">Preview (ลบบรรทัดว่างอัตโนมัติ)</div>
      </div>
      <div style="text-align:right">
        <div class="muted">Possible Keys:</div>
        <div id="possibleKeys" class="muted" style="margin-top:4px"></div>
      </div>
    </div>

    <div id="preview" class="output" tabindex="0"></div>
  </section>
</div>

<!-- Modal for selecting song from list -->
<div id="listPickerModal" style="display:none" class="modal-backdrop" role="dialog" aria-modal="true">
  <div class="modal" role="document">
    <h3>เลือกเพลงจากรายการ</h3>
    <div id="listPickerInfo" class="muted small" style="margin-bottom:8px"></div>
    <div id="listPickerItems"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button id="listPickerClose" class="btn secondary">ปิด</button>
    </div>
  </div>
</div>

<!-- html2pdf for PDF export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

<script>
/* ============================
   Music/transpose utils (same as before)
   ============================ */
const SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const FLATMAP = {"Db":"C#","Eb":"D#","Gb":"F#","Ab":"G#","Bb":"A#"};
const NOTE_TO_INDEX = {}; SHARP.forEach((n,i)=>NOTE_TO_INDEX[n]=i);
function normNote(n){ if(!n) return n; return (FLATMAP[n]||n).toUpperCase(); }
function isChordToken(tok){
  if(!tok) return false;
  let t = tok.trim();
  t = t.replace(/^[({\[]+|[)}\].,:!?]+$/g,"");
  if(/^[A-G](#|b)?:.+/.test(t)) return false;
  const lab = t.replace(/:$/,"");
  if(/^(intro|verse|chorus|bridge|outro|pre-chorus|prechorus)$/i.test(lab)) return false;
  return /^[A-G](#|b)?(m|min|maj|sus|dim|aug|add|M|maj7|m7|7|9|11|13|sus2|sus4|add9)?[0-9]*(\/[A-G](#|b)?)?$/i.test(t);
}
function transposeRoot(root,steps){ if(!root) return root; const r=normNote(root); const idx=NOTE_TO_INDEX[r]; if(idx===undefined) return root; return SHARP[(idx+steps+12)%12]; }
function transposeChordToken(tok,steps){ const m=tok.trim().match(/^([A-G](#|b)?)(.*?)(?:\/([A-G](#|b)?))?$/i); if(!m) return tok; const root=m[1], mod=m[3]||'', bass=m[4]||''; const nr=transposeRoot(root,steps); const nb=bass?transposeRoot(bass,steps):''; return nb? nr+mod+"/"+nb : nr+mod; }
function isMostlyChordLine(line){ const toks=line.trim().split(/\s+/).filter(Boolean); if(toks.length===0) return false; let c=0; toks.forEach(t=>{ if(isChordToken(t)) c++; }); return (c/toks.length) >= 0.5; }
const labelRegex=/^\s*(\[[^\]]+\]|\b(?:intro|verse|chorus|bridge|outro|pre-chorus|prechorus)\b[:\]]?)(?:\s*)(.*)$/i;
function processTokens(parts,steps){ return parts.map(p=>{ if(/^\s+$/.test(p)) return p; return isChordToken(p) ? transposeChordToken(p,steps) : p; }).join(''); }
function transposeAll(text,steps){ const lines=text.replace(/\r/g,'').split('\n'); const out=[]; for(const line of lines){ if(line.trim()===""){ out.push(''); continue; } const m=line.match(labelRegex); if(m){ const label=m[1],rest=m[2]||""; if(rest.trim()===""){ out.push(label); continue; } out.push(label+" "+processTokens(rest.split(/(\s+)/),steps)); continue; } if(isMostlyChordLine(line)){ out.push(processTokens(line.split(/(\s+)/),steps)); continue; } out.push(processTokens(line.split(/(\s+)/),steps)); } return out.join('\n'); }

/* ============================
   Key detection
   ============================ */
function extractChords(text){ const set=new Set(); const lines=text.split('\n'); for(const line of lines){ for(const t of line.split(/(\s+)/)){ if(isChordToken(t)) set.add(t.trim()); } } return [...set]; }
function detectPossibleKeys(tokens){
  const MAJOR_KEYS = {"C":["C","Dm","Em","F","G","Am","Bdim"],"C#":["C#","D#m","Fm","F#","G#","A#m","Cdim"],"D":["D","Em","F#m","G","A","Bm","C#dim"],"D#":["D#","Fm","Gm","G#","A#","Cm","Ddim"],"E":["E","F#m","G#m","A","B","C#m","D#dim"],"F":["F","Gm","Am","A#","C","Dm","Edim"],"F#":["F#","G#m","A#m","B","C#","D#m","Fdim"],"G":["G","Am","Bm","C","D","Em","F#dim"],"G#":["G#","A#m","Cm","C#","D#","Fm","Gdim"],"A":["A","Bm","C#m","D","E","F#m","G#dim"],"A#":["A#","Cm","Dm","D#","F","Gm","Adim"],"B":["B","C#m","D#m","E","F#","G#m","A#dim"]};
  const MINOR_KEYS = {"Am":["Am","Bdim","C","Dm","Em","F","G"],"A#m":["A#m","Cdim","C#","D#m","Fm","F#","G#"],"Bm":["Bm","C#dim","D","Em","F#m","G","A"],"Cm":["Cm","Ddim","D#","Fm","Gm","G#","A#"],"C#m":["C#m","D#dim","E","F#m","G#m","A","B"],"Dm":["Dm","Edim","F","Gm","Am","A#","C"],"D#m":["D#m","Fdim","F#","G#m","A#m","B","C#"],"Em":["Em","F#dim","G","Am","Bm","C","D"],"Fm":["Fm","Gdim","G#","A#m","Cm","C#","D#"],"F#m":["F#m","G#dim","A","Bm","C#m","D","E"],"Gm":["Gm","Adim","A#","Cm","Dm","D#","F"],"G#m":["G#m","A#dim","B","C#m","D#m","E","F#"],"Am2":["Am","Bdim","C","Dm","Em","F","G"]};
  let scores = [];
  let roots = tokens.map(t => {
    const m = t.match(/^([A-G](#|b)?)(m|min|maj)?/i);
    if(!m) return null;
    let base = normNote(m[1]);
    let type = (m[3]||"").toLowerCase();
    return (base + type).replace("maj","");
  }).filter(Boolean);
  if(roots.length === 0) return [];
  for(const key in MAJOR_KEYS){ const allowed = MAJOR_KEYS[key]; let count = roots.filter(r => allowed.includes(r)).length; let conf  = (count / roots.length) * 100; scores.push({key, mode:"major", score:conf}); }
  for(const key in MINOR_KEYS){ const allowed = MINOR_KEYS[key]; let count = roots.filter(r => allowed.includes(r)).length; let conf  = (count / roots.length) * 100; scores.push({key, mode:"minor", score:conf}); }
  scores.sort((a,b) => b.score - a.score);
  return scores.filter(s=>s.score>0).slice(0,3);
}
function semitoneDiff(from,to){ const f=NOTE_TO_INDEX[normNote(from)]; const t=NOTE_TO_INDEX[normNote(to)]; if(f===undefined||t===undefined) return 0; return (t-f+12)%12; }

/* ============================
   UI wiring & events
   ============================ */
const editor=document.getElementById('editor');
const preview=document.getElementById('preview');
const dec=document.getElementById('dec'), inc=document.getElementById('inc');
const range=document.getElementById('range'), transposeDisplay=document.getElementById('transposeDisplay'), stepsLabel=document.getElementById('stepsLabel');
const loadSample=document.getElementById('loadSample'), clearBtn=document.getElementById('clear');
const saveBtn=document.getElementById('save'), loadBtn=document.getElementById('load');
const presentModeBtn=document.getElementById('presentMode');
let currentSteps=0;

/* key buttons */
const keyButtonsEl=document.getElementById('keyButtons');
const KEYS=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
KEYS.forEach(k=>{
  const b=document.createElement('button');
  b.textContent=k;
  b.addEventListener('click', ()=>{
    const tokens = extractChords(editor.value);
    const possible = detectPossibleKeys(tokens);
    const base = (possible && possible.length>0) ? possible[0].key : 'C';
    currentSteps = semitoneDiff(base, k);
    updateUI();
  });
  keyButtonsEl.appendChild(b);
});

/* updateUI */
function linkifyAndEscape(s){
  if(!s) return '';
  const esc = s.replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  return esc.replace(/(https?:\/\/[^\s]+)/g, '<a class="preview-link" href="$1" target="_blank" rel="noopener">$1</a>');
}

function renderPreviewText(text){
  if(!text) text='';
  const lines = text.split('\n').map(l=>{
    if(/\[.*?\]/.test(l)) return '<div class="chordpro">'+escapeHtml(l)+'</div>';
    if(/^\s*([A-G][#b]?(m|min|maj|sus|dim|aug|add|7|m7|9|11|13)?(\/[A-G][#b]?)?\s+)+$/i.test(l)) return '<div class="chordpro">'+escapeHtml(l)+'</div>';
    return linkifyAndEscape(l);
  }).join('\n');
  preview.innerHTML = lines;
}
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

function updateUI(){
  const tokens = extractChords(editor.value);
  const possible = detectPossibleKeys(tokens);

  let text = "";
  if(possible && possible.length>0){
    possible.forEach(p=>{ text += `${p.key} ${p.mode} (${p.score.toFixed(1)}%)<br>`; });
  } else text = '(ไม่พบคอร์ด)';
  document.getElementById('possibleKeys').innerHTML = text;

  transposeDisplay.textContent = 'Transpose: ' + (currentSteps>=0?'+':'') + currentSteps;
  stepsLabel.textContent = currentSteps + ' semitones';

  let result = transposeAll(editor.value, currentSteps)
                .split('\n')
                .filter(line => line.trim() !== '')
                .join('\n');

  renderPreviewText(result);
  range.value = currentSteps;
}

/* events */
dec.addEventListener('click', ()=>{ currentSteps = Math.max(-12, currentSteps-1); updateUI(); });
inc.addEventListener('click', ()=>{ currentSteps = Math.min(12, currentSteps+1); updateUI(); });
range.addEventListener('input', e=>{ currentSteps = parseInt(e.target.value,10); updateUI(); });
editor.addEventListener('input', updateUI);

/* save/load */
function saveData(){ localStorage.setItem('chord_text', editor.value); localStorage.setItem('chord_steps', currentSteps); alert('บันทึกแล้ว'); }
function loadData(){ const t = localStorage.getItem('chord_text'); const s = localStorage.getItem('chord_steps'); if(!t){ alert('ไม่มีข้อมูลบันทึก'); return; } editor.value = t; currentSteps = parseInt(s||'0',10); updateUI(); }
saveBtn.addEventListener('click', saveData); loadBtn.addEventListener('click', loadData);

/* clear / sample */
clearBtn.addEventListener('click', ()=>{ editor.value=''; updateUI(); });
loadSample.addEventListener('click', ()=>{ editor.value =
`เพลง  ชีวีเราอยู่ในพระองค์
Intro: g  em  am  d

Chorus:
      G
C: ชีวีเราอยู่ในพระองค์
   Em
กำลังเราอยู่ในพระองค์
        C                        G/D          D
ความวางใจเราอยู่ในพระองค์  ในพระองค์

Verse:
        C                 D7/C            G/B  G
1: เราจะสรรเสริญ  ด้วยสุดสิ้นดวงจิต
    C                 D7/C          G/B  G
เราจะสรรเสริญ  ด้วยสุดสิ้นกำลัง
     D         G          E           Am
ด้วยสุดสิ้นชีวิต  ด้วยสุดสิ้นจิตใจ
F           C/E     D
ความวางใจอยู่ในพระองค์`; currentSteps = 0; updateUI(); });

/* presentation */
let present = false;
presentModeBtn.addEventListener('click', ()=>{ present = !present; if(present){ document.documentElement.requestFullscreen?.(); document.querySelectorAll('.card')[0].style.display = 'none'; preview.style.fontSize = '28px'; preview.style.lineHeight = '1.9'; } else { document.exitFullscreen?.(); document.querySelectorAll('.card')[0].style.display = ''; preview.style.fontSize = ''; preview.style.lineHeight = ''; } });

/* init */
editor.value = localStorage.getItem('chord_text') || '';
currentSteps = parseInt(localStorage.getItem('chord_steps')||'0',10);
updateUI();

/* ============================
   Export & Print (same)
   ============================ */
document.getElementById('exportTxt').addEventListener('click', ()=>{ const text = preview.innerText || editor.value || ''; const blob = new Blob([text], {type:'text/plain;charset=utf-8'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'song.txt'; a.click(); URL.revokeObjectURL(a.href); });

document.getElementById('exportDoc').addEventListener('click', ()=>{ const html = `<!doctype html><html><head><meta charset="utf-8"></head><body><pre style="white-space:pre-wrap;font-family:inherit;">${escapeHtml(preview.innerText || editor.value || '')}</pre></body></html>`; const blob = new Blob([html], {type:'application/msword'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'song.doc'; a.click(); URL.revokeObjectURL(a.href); });

document.getElementById('exportPdf').addEventListener('click', async ()=>{ const el = preview; const oldColor = el.style.color; const oldBg = el.style.background; el.style.color = "#000"; el.style.background = "#fff"; if(window.html2pdf){ const opt = { margin: 8, filename: 'song.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2, useCORS: true, backgroundColor: "#ffffff" }, jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' } }; try{ await html2pdf().set(opt).from(el).save(); }catch(e){ console.error(e); alert('เกิดข้อผิดพลาดขณะสร้าง PDF'); } } else { const w = window.open('', '_blank'); w.document.write('<html><head><meta charset="utf-8"><title>PDF</title></head><body><pre style="white-space:pre-wrap;font-family:inherit;color:#000;background:#fff;">' + escapeHtml(preview.innerText || '') + '</pre></body></html>'); w.document.close(); w.focus(); setTimeout(()=>w.print(), 600); } el.style.color = oldColor; el.style.background = oldBg; });

document.getElementById('printPreview').addEventListener('click', ()=>{ const w = window.open('', '_blank'); const content = preview.innerHTML; w.document.write(`<html><head><meta charset="utf-8"><title>Print Preview</title><style>body{font-family:"Sarabun",sans-serif;padding:24px;line-height:1.8;color:#000;background:#fff}pre,div{white-space:pre-wrap;font-family:"Sarabun",sans-serif;font-size:16px}a{color:#0077cc;text-decoration:underline}.chordpro{color:#007a4d;font-weight:600}</style></head><body>${content}</body></html>`); w.document.close(); w.focus(); w.print(); });

document.getElementById('printAsPdf').addEventListener('click', async ()=>{ const el = preview; const oldColor = el.style.color; const oldBg = el.style.background; el.style.color = "#000"; el.style.background = "#fff"; const opt = { margin: 8, filename: 'song.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2, useCORS: true, backgroundColor: "#ffffff" }, jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' } }; try{ const pdfBlob = await html2pdf().set(opt).from(el).outputPdf('blob'); const url = URL.createObjectURL(pdfBlob); const w = window.open(url, '_blank'); if(w){ w.onload = () => { try{ w.print(); }catch(e){} }; } else { const a = document.createElement('a'); a.href = url; a.download = 'song.pdf'; a.click(); } }catch(e){ console.error(e); alert('สร้าง PDF เพื่อพิมพ์ไม่สำเร็จ'); } finally { el.style.color = oldColor; el.style.background = oldBg; } });

/* ============================
   Search: DuckDuckGo with Bing-style site filters
   ============================ */
const ALLORIGINS = 'https://api.allorigins.win/raw?url=';
const doSearchBtn = document.getElementById('doSearch');
const searchQueryInput = document.getElementById('searchQuery');
const searchResultsBox = document.getElementById('searchResults');

doSearchBtn.addEventListener('click', ()=>{ let q = searchQueryInput.value.trim(); q = appendWorshipKeywords(q); doSearch(q); });
searchQueryInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); let q = searchQueryInput.value.trim(); q = appendWorshipKeywords(q); doSearch(q); } });

function appendWorshipKeywords(q){
  if(!q) return q;
  const sites = [
    "site:thaiworship.com",
    "site:deforever.com",
    "site:worshipthai.com",
    "site:christianthai.com",
    "site:lyrics.worshipsongs"
  ].join(" | ");
  return `lyrics ${q} เพลง นมัสการ ${sites}`;
}

async function doSearch(q){
  if(!q){ alert('กรุณาพิมพ์คำค้นหา เช่น "ชื่อเพลง"'); return; }
  searchResultsBox.innerHTML = '<div class="small">กำลังค้นหา... (DuckDuckGo)</div>';
  const duckUrl = 'https://duckduckgo.com/html/?q=' + encodeURIComponent(q);
  try{
    const res = await fetch(ALLORIGINS + encodeURIComponent(duckUrl));
    if(!res.ok) throw new Error('ไม่สามารถเข้าถึงผลลัพธ์ได้');
    const html = await res.text();
    renderSearchResultsFromDuckHtml(html, q);
  }catch(err){
    console.error(err);
    searchResultsBox.innerHTML = '<div class="small">ค้นหาไม่สำเร็จ — ลองอีกครั้งหรือตรวจสอบเครือข่าย</div>';
  }
}

/* clean DuckDuckGo redirect url if contains uddg=... (double decode) */
function cleanDuckUrl(url){
  if(!url) return "";
  try{
    const m = url.match(/uddg=([^&]+)/);
    if(m && m[1]){
      let decoded = decodeURIComponent(m[1]);
      try{ decoded = decodeURIComponent(decoded); }catch(e){}
      return decoded;
    }
    if(url.startsWith('file://') && url.includes('uddg=')){
      const mm = url.match(/uddg=([^&]+)/);
      if(mm && mm[1]) {
        let d = decodeURIComponent(mm[1]);
        try{ d = decodeURIComponent(d); }catch(e){}
        return d;
      }
    }
    if(!/^https?:\/\//i.test(url)){
      url = url.replace(/^file:\/\//i,'');
      if(!/^https?:\/\//i.test(url)) url = 'https://' + url.replace(/^https?:\/\//i,'');
    }
    return url;
  }catch(e){
    return url;
  }
}

/* clean snippet: remove chord tokens and control chars */
function cleanSnippet(s){
  if(!s) return '';
  s = s.replace(/\b[A-G][#b]?(m|min|maj|sus|dim|aug|add|M|maj7|m7|7|9|11|13)?(\/[A-G][#b]?)?\b/g, '');
  let t = s.replace(/\s+/g,' ').trim();
  t = t.replace(/[\u0000-\u001F\u007F-\u009F]/g,'');
  if(t.length > 350) t = t.slice(0,350) + '…';
  return t;
}

/* parse DuckDuckGo HTML results */
function renderSearchResultsFromDuckHtml(html, query){
  searchResultsBox.innerHTML = '';
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');

  let items = [];
  const candidates = doc.querySelectorAll('div.result, div.result__body, article.result, .result--organic, .web_result');
  if(candidates && candidates.length>0){
    candidates.forEach(node=>{
      try{
        const a = node.querySelector('a.result__a') || node.querySelector('a[href]');
        if(!a) return;
        const rawHref = a.getAttribute('href') || a.href || '';
        const href = cleanDuckUrl(rawHref);
        const title = (a.textContent || '').trim();
        const snippetNode = node.querySelector('.result__snippet') || node.querySelector('.result__abstract') || node.querySelector('.snippet') || node.querySelector('.result__extras') || node.querySelector('.c-abstract') || null;
        const snippet = snippetNode ? cleanSnippet(snippetNode.textContent) : '';
        items.push({title, href, snippet, thumb:''});
      }catch(e){}
    });
  }

  if(items.length === 0){
    const anchors = doc.querySelectorAll('a[href]');
    anchors.forEach(a=>{
      const hrefRaw = a.getAttribute('href') || '';
      const href = cleanDuckUrl(hrefRaw);
      const title = (a.textContent || '').trim();
      if(title && href) items.push({title, href, snippet:'', thumb:''});
    });
  }

  if(items.length === 0){
    searchResultsBox.innerHTML = '<div class="small">ไม่พบผลลัพธ์ — ลองคำค้นอื่น</div>';
    return;
  }

  items.slice(0,8).forEach((it, idx)=>{
    const row = document.createElement('div');
    row.className = 'sr-row';
    row.innerHTML = `
      <div style="flex:1">
        <div style="font-weight:700">${escapeHtml(it.title)}</div>
        <div class="muted" style="margin-top:6px">${escapeHtml(it.snippet)}</div>
        <div class="muted label" style="margin-top:6px;font-size:12px">${escapeHtml(it.href)}</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button class="btn secondary btn-insert" data-idx="${idx}">แทรก</button>
        <button class="btn secondary btn-fetch" data-idx="${idx}">ดึงคอร์ด/เนื้อเพลง</button>
        <a class="btn" href="${it.href}" target="_blank" rel="noopener">เปิด</a>
      </div>
    `;
    searchResultsBox.appendChild(row);
  });

  // attach handlers
  Array.from(searchResultsBox.querySelectorAll('.btn-insert')).forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const idx = parseInt(btn.getAttribute('data-idx'),10);
      const it = items[idx];
      if(!it) return;
      const cleanHref = cleanDuckUrl(it.href || '');
      const cleanedSnippet = cleanSnippet(it.snippet || '');
      const block = buildInsertBlock(query, it.title || '(ไม่พบชื่อ)', cleanHref, cleanedSnippet);
      insertIntoEditorAtCursorOrAppend(block);
      updateUI();
      searchResultsBox.innerHTML = `<div class="small">แทรกเรียบร้อย: ${escapeHtml(it.title || '')}</div>`;
    });
  });

  Array.from(searchResultsBox.querySelectorAll('.btn-fetch')).forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const idx = parseInt(btn.getAttribute('data-idx'),10);
      const it = items[idx];
      if(!it || !it.href){ alert('ลิงก์ไม่ถูกต้อง'); return; }
      btn.textContent = 'กำลังดึง...';
      try{
        const url = cleanDuckUrl(it.href);
        // NEW: support list pages - detect and show picker
        await handleFetchFromSearchResult(url, query);
      }catch(e){
        console.error(e);
        alert('ดึงเนื้อเพลงไม่สำเร็จ');
      } finally {
        btn.textContent = 'ดึงคอร์ด/เนื้อเพลง';
      }
    });
  });
}

/* build insert block */
function buildInsertBlock(query, title, href, snippet){
  href = href || '';
  snippet = snippet || '';
  if(href && !/^https?:\/\//i.test(href)) {
    href = 'https://' + href.replace(/^https?:\/\//i,'');
  }
  return `————————————
ค้นหา: ${query}
ผลลัพธ์:
${title}

ลิงก์:
${href}

คำอธิบาย:
${snippet}

————————————

`;
}

function insertIntoEditorAtCursorOrAppend(text){
  const ta = editor;
  if(document.activeElement === ta){
    const start = ta.selectionStart, end = ta.selectionEnd;
    const before = ta.value.slice(0,start), after = ta.value.slice(end);
    ta.value = before + text + after;
    const pos = before.length + text.length;
    ta.setSelectionRange(pos,pos);
  } else {
    if(ta.value && !ta.value.endsWith('\n')) ta.value += '\n';
    ta.value += text;
  }
}

/* ============================
   NEW: handle fetch from search result — detect list page and prompt selection
   ============================ */
async function handleFetchFromSearchResult(url, originalQuery){
  try{
    const api = ALLORIGINS + encodeURIComponent(url);
    const res = await fetch(api);
    if(!res.ok) throw new Error('ไม่สามารถโหลดหน้าเว็บได้');
    const html = await res.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');

    // detect list page for deforever or thaiworship
    const host = (new URL(url)).hostname.toLowerCase();

    // If deforever/songList or contains many links -> treat as list
    if(host.includes('deforever.com') && /songlist|songList|songlist.php|songList.php/i.test(url)){
      const list = parseDeForeverList(doc, url);
      if(list && list.length>0){
        showListPicker(list, originalQuery, url, 'deforever');
        return;
      }
    }

    // thaiworship: if page contains many song links (category/tag), use parser
    if(host.includes('thaiworship.com') && detectIsThaiWorshipList(doc)){
      const list = parseThaiWorshipList(doc, url);
      if(list && list.length>0){
        showListPicker(list, originalQuery, url, 'thaiworship');
        return;
      }
    }

    // fallback: not a list — parse single page content normally
    const fetched = await fetchChordAndLyrics(url); // existing function will parse single page
    insertIntoEditorAtCursorOrAppend(`\n\n${fetched}\n\n`);
    updateUI();
  }catch(err){
    console.error(err);
    alert('ไม่สามารถประมวลผลลิงก์นี้ได้');
  }
}

/* detect thaiworship list heuristics */
function detectIsThaiWorshipList(doc){
  // if there are many article links or post-list classes
  const anchors = doc.querySelectorAll('a[href]');
  let countSongLike = 0;
  anchors.forEach(a=>{
    const href = a.getAttribute('href')||'';
    if(/\/\d{4}\/\d{2}\/|\/category\/|\/tag\/|\/lyrics\/|\/song\//i.test(href)) countSongLike++;
  });
  return countSongLike > 6;
}

/* parse list from deforever (extract song links & titles) */
function parseDeForeverList(doc, baseUrl){
  const items = [];
  // deforever song lists often have <a href="songdetail.php?id=...">text</a> or tables
  const anchors = doc.querySelectorAll('a[href]');
  anchors.forEach(a=>{
    const href = a.getAttribute('href') || '';
    const txt = (a.textContent||'').trim();
    if(!txt) return;
    // filter likely song links
    if(/songdetail\.php|song\.php|songID|songId|/i.test(href) || /song|เพลง|lyrics/gi.test(txt)){
      const url = resolveUrl(baseUrl, href);
      items.push({title:txt, href:url});
    }
  });
  // dedupe by href
  return dedupeList(items);
}

/* parse list from thaiworship (category/tag pages) */
function parseThaiWorshipList(doc, baseUrl){
  const items = [];
  // common selectors: .entry-title a, .post-title a, .td-module-title a
  const sel = ['.entry-title a', '.post-title a', '.td-module-title a', '.entry a', 'h2 a', 'h3 a'];
  sel.forEach(s=>{
    doc.querySelectorAll(s).forEach(a=>{
      const href = a.getAttribute('href') || '';
      const txt = (a.textContent||'').trim();
      if(!txt || !href) return;
      items.push({title: txt, href: resolveUrl(baseUrl, href)});
    });
  });
  // fallback: scan anchors under main content
  if(items.length===0){
    const anchors = doc.querySelectorAll('a[href]');
    anchors.forEach(a=>{
      const href = a.getAttribute('href')||'';
      const txt = (a.textContent||'').trim();
      if(!txt) return;
      if(/\/lyrics\/|\/tag\/|\/category\/|\/song|เพลง|lyrics/gi.test(href+txt)){
        items.push({title:txt, href: resolveUrl(baseUrl, href)});
      }
    });
  }
  return dedupeList(items);
}

/* dedupe items by href and reasonable title length */
function dedupeList(items){
  const map = new Map();
  items.forEach(it=>{
    const key = (it.href||'').split('#')[0];
    if(!key) return;
    if(!map.has(key) && it.title.length>1){
      map.set(key, {title: it.title.replace(/\s+/g,' ').trim(), href: key});
    }
  });
  return Array.from(map.values());
}

/* resolve relative URLs */
function resolveUrl(base, href){
  try{
    return new URL(href, base).href;
  }catch(e){
    return href;
  }
}

/* show modal list picker with fuzzy ranking */
function showListPicker(list, query, listUrl, siteKey){
  const modal = document.getElementById('listPickerModal');
  const info = document.getElementById('listPickerInfo');
  const itemsDiv = document.getElementById('listPickerItems');
  itemsDiv.innerHTML = '';
  info.textContent = `พบ ${list.length} รายการจาก: ${listUrl} — เลือกเพลงที่ต้องการ (ค้นหา: "${query}")`;

  const ranked = rankListByQuery(list, query).slice(0,25); // show top 25
  if(ranked.length===0){
    itemsDiv.innerHTML = '<div class="muted">ไม่พบรายการที่เกี่ยวข้องในหน้านี้</div>';
  } else {
    ranked.forEach((it, idx)=>{
      const row = document.createElement('div');
      row.className = 'song-row';
      row.innerHTML = `
        <div class="song-left">
          <div class="song-title">${escapeHtml(it.title)}</div>
          <div class="song-meta">${escapeHtml(it.href)}</div>
        </div>
        <div class="song-actions">
          <span class="score-badge">${(it.score*100).toFixed(0)}%</span>
          <div style="height:8px"></div>
          <div style="display:flex;gap:6px">
            <button class="btn secondary pick-song" data-idx="${idx}">ดึงเพลงนี้</button>
            <a class="btn" href="${it.href}" target="_blank" rel="noopener">เปิด</a>
          </div>
        </div>
      `;
      itemsDiv.appendChild(row);
    });

    // handlers for pick buttons
    Array.from(itemsDiv.querySelectorAll('.pick-song')).forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const idx = parseInt(btn.getAttribute('data-idx'),10);
        const it = ranked[idx];
        if(!it) return;
        // close modal
        closeListPicker();
        // fetch the selected song page and parse
        try{
          const fetched = await fetchChordAndLyrics(it.href);
          insertIntoEditorAtCursorOrAppend(`\n\n${fetched}\n\n`);
          updateUI();
        }catch(e){
          console.error(e);
          alert('ดึงเพลงไม่สำเร็จ');
        }
      });
    });
  }

  // show modal
  modal.style.display = 'flex';
}

/* close modal */
function closeListPicker(){
  const modal = document.getElementById('listPickerModal');
  modal.style.display = 'none';
}
document.getElementById('listPickerClose').addEventListener('click', closeListPicker);

/* rank list by fuzzy token overlap */
function rankListByQuery(list, query){
  const qTokens = tokenizeForMatch(query);
  return list.map(it=>{
    const title = it.title || '';
    const tTokens = tokenizeForMatch(title);
    const score = tokenOverlapScore(qTokens, tTokens);
    return {...it, score};
  }).sort((a,b)=>b.score - a.score);
}

/* tokenize: lowercase, remove punctuation, split tokens, keep thai and english words */
function tokenizeForMatch(s){
  if(!s) return [];
  const t = s.toLowerCase().replace(/[^\p{L}\p{N}\s]+/gu,' ');
  const toks = t.split(/\s+/).filter(Boolean).map(x=>x.trim());
  return toks;
}

/* token overlap score: intersection / union */
function tokenOverlapScore(a,b){
  if(!a.length || !b.length) return 0;
  const A = new Set(a);
  const B = new Set(b);
  let inter = 0;
  A.forEach(x=>{ if(B.has(x)) inter++; });
  const union = new Set([...A,...B]).size;
  return inter / union;
}

/* ============================
   Fetch lyrics & chords from target page (via AllOrigins)
   site-specific parsers for thaiworship.com & deforever.com
   ============================ */
async function fetchChordAndLyrics(url){
  if(!url) return '⚠ ลิงก์ไม่ถูกต้อง';
  try{
    const api = ALLORIGINS + encodeURIComponent(url);
    const res = await fetch(api);
    if(!res.ok) throw new Error('ไม่สามารถโหลดหน้าเว็บได้');
    const html = await res.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');

    // domain detection
    let host = '';
    try { host = new URL(url).hostname.toLowerCase(); } catch(e){ host = ''; }

    // If it's clearly a list page, return a special marker (handled upstream)
    if(host.includes('deforever.com') && /songlist|songList|songlist.php|songList.php/i.test(url)){
      // the caller should have detected and handled list pages
      // fallback: parse list and choose first
      const list = parseDeForeverList(doc, url);
      if(list.length>0) {
        // choose first item as fallback
        const sel = list[0];
        return await fetchChordAndLyrics(sel.href);
      }
    }

    if(host.includes('thaiworship.com') && detectIsThaiWorshipList(doc)){
      const list = parseThaiWorshipList(doc, url);
      if(list.length>0){
        const sel = list[0];
        return await fetchChordAndLyrics(sel.href);
      }
    }

    // site-specific single-page parsing
    if(host.includes('thaiworship.com')) return parseThaiWorshipSongPage(doc, url);
    if(host.includes('deforever.com')) return parseDeForeverSongPage(doc, url);

    // fallback: generic parse
    return genericParse(doc, url);
  }catch(err){
    console.error(err);
    return '⚠ โหลดเนื้อเพลงไม่สำเร็จ (อาจถูกป้องกันโดยเว็บเป้าหมาย)';
  }
}

/* parse single song page: thaiworship */
function parseThaiWorshipSongPage(doc, url){
  // try common selectors
  const selectors = ['.entry-content', '.post-content', '.lyrics', '.song-lyrics', '.wp-block-lyrics', 'pre'];
  for(const s of selectors){
    const el = doc.querySelector(s);
    if(el){
      let t = (el.innerText || el.textContent || '').replace(/\r/g,'').trim();
      t = t.replace(/\n{3,}/g,'\n\n');
      if(t.length>40) return `ดึงจาก: ${url}\n\n${t}`;
    }
  }
  // fallback: largest block
  const fallback = fallbackLargestTextBlock(doc);
  if(fallback) return `ดึงจาก: ${url}\n\n${fallback}`;
  return '⚠ ไม่พบเนื้อเพลงในหน้านี้ (thaiworship)';
}

/* parse single song page: deforever */
function parseDeForeverSongPage(doc, url){
  const selectors = ['.songtext', '.songContent', '.lyrics', '.lyric', '.entry-content', 'pre', '.content', '.post-content'];
  for(const s of selectors){
    const el = doc.querySelector(s);
    if(el){
      let t = (el.innerText || el.textContent || '').replace(/\r/g,'').trim();
      t = t.replace(/\n{3,}/g,'\n\n');
      if(t.length>40) return `ดึงจาก: ${url}\n\n${t}`;
    }
  }
  const fallback = fallbackLargestTextBlock(doc);
  if(fallback) return `ดึงจาก: ${url}\n\n${fallback}`;
  return '⚠ ไม่พบเนื้อเพลงในหน้านี้ (deforever)';
}

/* generic parse fallback */
function genericParse(doc, url){
  const selectors = ['.entry-content', '.post-content', '.lyrics', '.lyric', '.song-lyrics', '.chords', 'pre', '.content', 'article'];
  for(const s of selectors){
    const el = doc.querySelector(s);
    if(el){
      let t = (el.innerText || el.textContent || '').replace(/\r/g,'').trim();
      t = t.replace(/\n{3,}/g,'\n\n');
      if(t.length>50) return `ดึงจาก: ${url}\n\n${t}`;
    }
  }
  const fallback = fallbackLargestTextBlock(doc);
  if(fallback) return `ดึงจาก: ${url}\n\n${fallback}`;
  const bodyText = (doc.body && doc.body.innerText)? (doc.body.innerText.replace(/\r/g,'').replace(/\n{3,}/g,'\n\n').trim()) : '';
  if(bodyText.length>80) return `ดึงจาก: ${url}\n\n${bodyText}`;
  return '⚠ ไม่พบเนื้อเพลงหรือคอร์ดในหน้านี้';
}

/* fallbackLargestTextBlock reused */
function fallbackLargestTextBlock(doc){
  const nodes = Array.from(doc.querySelectorAll('p, div, section, article, pre'));
  let best={score:0,text:''};
  nodes.forEach(node=>{
    const t=(node.innerText||node.textContent||'').replace(/\r/g,'').trim();
    if(t.length<40) return;
    let score = 0;
    if(/[ก-๙]/.test(t)) score += 5;
    if(/\b[A-G][#b]?(m|min|maj|sus|dim|aug|add|7|m7|9|11|13)?(\/[A-G][#b]?)?\b/.test(t)) score += 4;
    score += Math.min(20, t.length/50);
    if(score>best.score){ best={score, text:t}; }
  });
  return best.text.replace(/\n{3,}/g,'\n\n').trim();
}

/* ============================
   Convert to ChordPro (heuristic)
   ============================ */
function convertToChordPro(raw){
  if(!raw) return '';
  const lines = raw.split('\n').map(l=>l.replace(/\r/g,''));
  const out = [];
  for(let i=0;i<lines.length;i++){
    const L = lines[i].trim();
    if(!L) continue;
    if(isMostlyChordLine(L)){
      const next = (lines[i+1]||'').trim();
      if(next && !isMostlyChordLine(next)){
        const chords = L.split(/\s+/).filter(Boolean);
        const words = next.split(/\s+/);
        const combined = [];
        let ci=0;
        for(let wi=0; wi<words.length; wi++){
          if(ci < chords.length){
            combined.push('['+chords[ci++]+']' + words[wi]);
          } else {
            combined.push(words[wi]);
          }
        }
        out.push(combined.join(' '));
        i += 1;
        continue;
      } else {
        out.push('{comment: chords} ' + L);
        continue;
      }
    } else {
      const m = L.match(/^([A-G][#b]?(m|min|maj|sus|dim|add|M|7)?):\s*(.*)$/i);
      if(m){
        out.push('['+m[1]+'] '+m[3]);
      } else {
        out.push(L);
      }
    }
  }
  return out.filter(Boolean).join('\n');
}

/* ============================
   Utility functions end
   ============================ */

</script>
</body>
</html>
